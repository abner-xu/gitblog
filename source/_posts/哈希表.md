---
title: 哈希表
categories:
  - 后端
  - 数据结构
tags:
  - 数据结构算法
comments: true
toc: true
abbrlink: 850f2080
date: 2019-02-16 22:19:14
---

hash底层其实就是数组实现
# 普通代码实现
```java
package hash;

import java.math.BigInteger;

public class HashTable {
    private Info[] arr;

    public HashTable() {
        arr = new Info[100];
    }

    public HashTable(int maxSize) {
        arr = new Info[maxSize];
    }

    public void insert(Info info) {
        arr[hashCode(info.getKey())] = info;
    }


    public Info find(String key) {
        return arr[hashCode(key)];
    }

    public int hashCode(String key) {
        BigInteger hashVal = new BigInteger("0");
        BigInteger pow27 = new BigInteger("1");
        for (int i = key.length() - 1; i >= 0; i--) {
            int letter = key.charAt(i) - 96;
            BigInteger letterB = new BigInteger(String.valueOf(letter));
//            hashVal+=pow27;
//            pow27*=27;
            hashVal = hashVal.add(letterB.multiply(pow27));
            pow27 = pow27.multiply(new BigInteger(String.valueOf(27)));
        }

        return hashVal.intValue();
    }

}

```



#hashcode计算方式
## 开放地址法
当冲突发生时，通过查找数组的一个空位，并将数据填入，而不再哈希函数得到的数组下标，这个方法叫做开放地址法
```java
 public void insert(Info info) {
        int hashVal = hashCode(info.getKey());
        while (arr[hashVal] != null && arr[hashVal].getName() != null) {
            //进行递增
            ++hashVal;
            //循环
            hashVal %= arr.length;
        }
        arr[hashVal] = info;
    }


    public Info find(String key) {
        int hashVal = hashCode(key);
        while (arr[hashVal] != null) {
            if (arr[hashVal].getKey().equals(key)) {
                return arr[hashVal];
            }
            //进行递增
            ++hashVal;
            //循环
            hashVal %= arr.length;
        }
        return null;
    }
    
    public Info delete(String key){
        int hashVal = hashCode(key);
        while (arr[hashVal] != null) {
            if (arr[hashVal].getKey().equals(key)) {
                Info temp= arr[hashVal];
                arr[hashVal]=null;
                return temp;
            }
            //进行递增
            ++hashVal;
            //循环
            hashVal %= arr.length;
        }
        return null;
    }
```
## 链地址法
在哈希表每个单元中设置链表。某个数据项的关键字还是映射到哈希表，数据放入链表中,后续操作基本上和链表操作一致

```java
private LinkList[] arr;

public HashTable() {
    arr = new LinkList[100];
}

public HashTable(int maxSize) {
    arr = new LinkList[maxSize];
}

public void insert(Info info) {
    int hashVal = hashCode(info.getKey());
    if (arr[hashVal]==null){
        arr[hashVal]=new LinkList();
    }
    arr[hashVal].addHead(info);
}


public Info find(String key) {
    int hashVal = hashCode(key);
    arr[hashVal].find(key).data;
}



//相比原来的LinkList 做了修改
/**
//     * 链表查找
//     */
//    public Node find(String key) {
//        Node current = head;
//        while (key.equals(current.data.getKey())) {  //==这里修改成按照key进行比较==
//            if (current.next == null) {
//                return null;
//            }
//            current = current.next;
//        }
//        return current;
//    }
//
//    public Node delValue(String key) {
//        Node current = head;
//        Node pre = head;//上一个节点
//        while (!key.equals(current.data.getKey())) { //=====这里修改成按照key进行比较==
//            if (current.next == null) {
//                return null;
//            }
//            pre = current;
//            current = current.next;
//        }
//
//        if (current == head) {  //如果删除的是第一个节点
//            head = current.next;
//        } else {  //删除的不是第一个节点
//            pre.next = current.next;
//        }
//
//        return current;
//
//    }

```