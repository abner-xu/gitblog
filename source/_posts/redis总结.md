---
title: redis总结
categories:
  - 后端
  - Redis
tags:
  - 面试知识
comments: true
toc: true
date: 2019-02-27 20:49:03
---
# 一、Redis为什么那么快

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞I/O多路复用机制

我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。



# 二、Redis的过期策略以及内存淘汰机制

## 2.1　三种过期策略

    定时删除：在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作；

    惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；

    定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。

Redis采用的是定期删除+惰性删策略。  

    为什么不用定时删除策略？定时删除策略需要定时器来监视key，过期则自动删除。虽然内存及时释放了，但是CPU消耗大。在大并发的情况下，这一策略得不偿失

Redis采用的是定期删除+惰性删策略工作机制。  

    定期删除，redis默认每100ms检查一次是否存在过期key，有则删除。需要说明的是redis并不是100ms检查所有的key一次，而是随机进行抽取检查。因此，惰性删除派上用处。

惰性删策略延伸出来的问题就是，redis缓存淘汰机制

## 2.2　Redis(3.0版本)6种缓存淘汰机制

    1） no-enviction(驱逐)：禁止驱逐数据（不删除数据策略，达到最大的内存限制时，如果有更多的数据写入，返回错误给客户端）
    2）allkeys-lru：所有key通用，优先删除最少使用的key（less recently used,LRU算法）
    3）allkeys-random ：素有key通用，随机删除一部分key
    4）volatile-lru：只限于设置了expire的部分，优先删除最少使用的key（less recently used,LRU算法）
    5）volatile-random：只限于设置了 expire 的部分; 随机删除一部分key
    6）volatile-ttl：只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。

注意：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。  

一般来说：如果分为热数据与冷数据, 推荐使用allkeys-lru策略。 也就是, 其中一部分key经常被读写. 如果不确定具体的业务特征, 那么allkeys-lru是一个很好的选择。 如果需要循环读写所有的key, 或者各个key的访问频率差不多, 可以使用allkeys-random策略, 即读写所有元素的概率差不多。  

假如要让 Redis 根据 TTL 来筛选需要删除的key, 请使用volatile-ttl策略。




# 三、Redis和数据库双写一致性问题

一致性问题是分布式系统常见问题，可以分为最终一致性和强一致性。所以弄清诉求
数据库强一致性，不放缓存，我们所做的一切只是保证最终一致性，另外无法完全避免，讨论三种更新策略：

    1. 先更新数据库，再更新缓存
    2. 先删除缓存，再更新数据库
    3. 先更新数据库，再删除缓存

## 3.1 先更新数据库，再更新缓存

这套方案，大家是普遍反对的，为什么呢？有如下两点原因：

原因一、线程安全问题，同时有请求A和请求B进行更新操作，那么会出现：

    线程A更新了数据库
    线程B更新了数据库
    线程B更新了缓存
    线程A更新了缓存

    这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B比A更早更新了缓存。这就导致了脏数据，因此不考虑！

原因二、业务场景考虑

    1）如果是写数据库场景比较多，读数据库场景比较少业务需求。"先更新数据库，再更新缓存"这种方案会导致，数据压根还没读到，缓存就被频繁的更新浪费性能
    2）如果写入数据库是经过复杂计算以后再更新数据库，那么每次写入数据库后更新缓存，性能存在浪费

## 3.2 先删除缓存，再更新数据库 

该方案会导致不一致的原因：同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么就会出现以下情形：

情况一：多进程读写原因

    请求A进行写操作，删除缓存
    请求B查询发现缓存不存在
    请求B去数据库查询得到旧值
    请求B将旧值写入缓存
    请求A将新值写入数据库
    上诉请求出现不一致的情况，如果没采用缓存过期策略。则缓存数据一直是脏数据。

情况二：MYSQL主从分离原因

    请求A进行写操作，删除缓存；
    请求A将数据写入数据库了；
    请求B查询缓存发现，缓存没有值；
    请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值；
    请求B将旧值写入缓存；
    数据库完成主从同步，从库变为新值；

解决方案：采用延迟双删策略。先删除缓存，再删除数据库，进程休眠1秒再次删除缓存

## 3.3先更新数据库，再删除缓存

    这种情况不存在并发问题么？
    不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生：
    （1）缓存刚好失效；
    （2）请求A查询数据库，得一个旧值；
    （3）请求B将新值写入数据库；
    （4）请求B删除缓存；
    （5）请求A将查到的旧值写入缓存；
    ok，如果发生上述情况，确实是会发生脏数据。

解决方案：发生上述情况有一个先天性条件，就是6.1中步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。  首先，给缓存设有效时间是一种方案。其次，采用策略2（先删除缓存，再更新数据库）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。