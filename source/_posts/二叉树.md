---
title: 二叉树
categories:
  - 后端
  - 数据结构
tags:
  - 二叉树
comments: true
toc: true
date: 2019-02-25 22:20:03
---
# 代码实现
```
package tree;

/**
 * 二叉树
 */
public class erchaTree {
    //根节点
    private Node root;

    public void insert(int value) {
        //封装节点
        Node newNode = new Node(value);
        //引用当期节点
        Node current = root;
        Node parent;
        //如果是开始节点
        if (root == null) {
            root = newNode;
            return;
        }
        while (true) {
            //父节点指向当期节点
            parent = current;
            //如果当前指向的节点数据比插入的要大，则向左走
            if (current.data > value) {
                current = current.leftChild;
                if(current==null){
                    parent.leftChild=newNode;
                    return;
                }
            } else {
                current = current.rightChild;
                if(current==null){
                    parent.rightChild=newNode;
                    return;
                }
            }
        }


    }

    /**
     * 查找
     *
     * @param value
     * @return
     */
    public Node find(int value) {
        //引用当前节点
        Node current = root;
        //循环，只要查找的值不等于数据项
        while (current.data != value) {
            if (current.data > value) {
                current = current.leftChild;
            } else {
                current = current.rightChild;
            }
            if (current == null) {
                return null;
            }
        }
        return current;
    }

    public boolean delete(int value) {
        //引用当前节点，从根节点开始
        Node current = root;
        //引用当前节点的父节点
        Node parent = root;
        //是否为左节点
        boolean isLeftChild = true;

        while (current.data != value) {
            //父节点指向当期节点
            parent = current;
            //如果当前指向的节点数据比插入的要大，则向左走
            if (current.data > value) {
                current = current.leftChild;
                isLeftChild = true;
            } else {
                current = current.rightChild;
                isLeftChild = false;
            }
            //未找到
            if (current == null) {
                return false;
            }
        }
        //情况1：没有子节点,删除叶子节点，即该节点没有子节点
        if (current.leftChild == null && current.rightChild == null) {
            if (current == root) {
                root = null;
            } else if (isLeftChild) {
                parent.leftChild = null;
            } else {
                parent.rightChild = null;
            }
        } else if (current.rightChild == null) {  //情况2：删除的节点只有左节点
            if (current == root) {
                root = null;
            } else if (isLeftChild) {
                parent.leftChild = current.leftChild;
            } else {
                parent.rightChild = current.rightChild;
            }
        } else if (current.leftChild == null) {  //情况3：删除节点只有右节点
            if (current == root) {
                root = null;
            } else if (isLeftChild) {
                parent.leftChild = current.rightChild;
            } else {
                parent.rightChild = current.rightChild;
            }
        }else{//情况4：删除节点有两个子节点 && //有两个节点,找到后继节点，将值赋给删除节点，然后将后继节点删除掉即可
            Node successor = getSuccessor(current);
            if (current==root){
                root=successor;
            }else if (isLeftChild){
                parent.leftChild=successor;
            }else{
                parent.rightChild=successor;
            }
            successor.leftChild=current.leftChild;
            

        }
        return true;
    }

    /**
     * 中级后续节点的查找规则，删除节点的右节点往下走一步节点，然后沿左子树一直找下去
     * @param delNode
     * @return
     */
    public Node getSuccessor(Node delNode){
        Node successor=delNode;//中继节点
        Node successorParent=delNode;//中继父节点
        Node current=delNode.rightChild;//中继右侧
        while (current!=null){
            successorParent=successor;
            successor=current;
            current=current.leftChild;
        }
        if(successor !=delNode.rightChild){
            successorParent.leftChild=successor.rightChild;
            successor.rightChild=delNode.rightChild;
        }
        return successor; 
    }
    
     /**
     * 前序遍历，相对于从根节点，一路寻找左子树
     */
    public void frontOrder(Node localNode) {
        if (localNode == null) {
            return;
        }
        //访问根节点
        System.out.println(localNode.data+","+localNode.name);
        //前序遍历左子树
        frontOrder(localNode.leftChild);
        //前序遍历右子树
        frontOrder(localNode.rightChild);
    }

    /**
     * 中序遍历：特点是数据从大到小
     * @param localNode
     */
    public void inOrder(Node localNode){
        if (localNode == null) {
            return;
        }
        //前序遍历左子树
        inOrder(localNode.leftChild);
        //访问根节点
        System.out.println(localNode.data+","+localNode.name);
        //前序遍历右子树
        inOrder(localNode.rightChild);
    }

    /**
     * 后序遍历：特点是数据从大到小
     * @param localNode
     */
    public void afterOrder(Node localNode){
        if (localNode == null) {
            return;
        }
        //前序遍历左子树
        afterOrder(localNode.leftChild);
        //前序遍历右子树
        afterOrder(localNode.rightChild);
        //访问根节点
        System.out.println(localNode.data+","+localNode.name);
    }

}

```
# NODE
```
/**
 * 二叉树节点
 */
public class Node {
    //数据项
    public int data;
    //左子节点
    public Node leftChild;
    //右子节点
    public Node rightChild;
    
    public Node (int data){
        this.data=data;
    }
    
}
```

# 前序遍历图解
1.  访问根节点
2.  遍历左子树
3.  遍历右子树
![image](https://ws4.sinaimg.cn/large/0078bOVFgy1g07h5g6oqoj30hf083wfq.jpg)
# 中序遍历图解
2.  遍历左子树
1.  访问根节点
3.  遍历右子树
![image](https://ws3.sinaimg.cn/large/0078bOVFgy1g07h8bpdtxj30gp08175d.jpg)
# 后序遍历图解
2.  遍历左子树
3.  遍历右子树
1.  访问根节点
![image](https://ws4.sinaimg.cn/large/0078bOVFgy1g07h5g6oqoj30hf083wfq.jpg)
