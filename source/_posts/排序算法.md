---
title: 排序算法
categories:
  - 后端
  - 算法
tags:
  - 排序算法
  - 数据结构算法
comments: true
toc: true
date: 2019-02-06 22:25:12
---
## 有序插入
说明:
-   2[0],4[1],5[2],6[3]  添加3进来，需要将4，5，6后移，整个赋值操作需要从后面6，5，4 进行
-   然后将1号位让出来
```java
public void sort_insert(long value) {
        int i;
        for (i = 0; i < elements; i++) {
            if (arr[i] > value) {
                break;
            }
        }
        for (int j = elements; j > i; j--) {
            arr[j]=arr[j-1];
        }
        arr[i]=value;
        elements++;

    }
```

## 二分查找法
```java
public int binarySearch(long value){
        int middle=0;//数组中间索引
        int low=0;//左边偏小的初始索引
        int pow=elements;//右边偏大的初始索引
        while (true){
            middle=(pow+low)/2; //获取索引的平均值
            if(arr[middle]==value){
                return middle;
            }else if(low>pow){
                return -1;
            }else {
                if(arr[middle]>value){//往左边走
                    pow=middle-1;
                }else {
                    low=middle+1;
                }
            }
        }
    }
```

## 冒泡排序
```java
public static void sort(long[] arr){
        long tmp=0;
        for (int i = 0; i < arr.length-1; i++) {  //遍历数据
            for (int j=0; j<arr.length-i-1; j++) { //俩俩比较
                if(arr[j]<arr[j-1]){
                    tmp=arr[j];
                    arr[j]=arr[j-1];
                    arr[j-1]=tmp;
                }
            }           
        }
    }
```
## 选择排序
```java
public static void sort(long[] arr){
        int k=0;//游标
        int  temp=0;
        for (int i=0;i<arr.length-1;i++){
            k=i;//默认给到第一个
            for (int j=i;j<arr.length;j++){//从所有数组中找到比当前k小的
                if(arr[j]<arr[k]){
                    k=j;
                }
            }
            temp=arr[i];
            arr[i]=arr[k];
            arr[k]=temp;
            
        }
    }
```

## 插入排序
```
public static void sort(long[] arr){
     int temp;
        for (int i = 1; i < arr.length; i++) {//从index=1开始插入排序，i=0在他之前无数据
            temp = arr[i];
            int j = i;
            while (j > 0 && arr[j] >= temp) {
                //数据往又移
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = temp;
        }       
}
```

## 希尔排序
1.	希尔排序的产生
	希尔排序基于插入排序，并添加了一些新特性，从而大大提供了插入排序的效率
2.	插入排序的缺陷，多次的移动
	一个很小的数据在末端。那么进行排序需要把所有的数据右移一位
3.	希尔排序的优点
	希尔排序通过加大插入排序中的元素之间的间隔，并对这些间隔的元素进行插入排序，从而使得数据可以进行大幅度的移动。当完成间隔的排序后，希尔排序会减少数据的间隔再次进行排序。依次进行下去
4. 	间隔的计算
	间隔初始值h=1,通过h=3*h+1来循环计算，直到改间隔大于数组的长度停止
5.	间隔减少
	h=(h-1)/3来计算
```
    /**
     * 希尔排序
     */
    public void shellsort() {
        int[] arr = new int[]{35, -1, 77, 90, 0,85,73,19,56,-69,-896,-458,1987,1123};


        //初始化一个间隔
        int h = 1;
        //计算最大间隔 h=h*3+1 固定公式
        while (h < arr.length / 3) {
            h = h * 3 + 1;
        }
        while (h > 0) {
            //进行插入排序
            int tmp = 0;
            for (int i = h; i < arr.length; i++) {
                tmp = arr[i];
                int j = i;
                while (j > h - 1 && arr[j - h] > tmp) {
                    arr[j] = arr[j - h];
                    j -= h;
                }
                arr[j] = tmp;
            }
            //减小间隔
            h = (h - 1) / 3;
        }

        
        //打印数组
        System.out.println();
        System.out.println("排序后的数组为：");
        for (int num : arr) {
            System.out.print(num + " ");
        }
        
    }
```


## 快速排序
1.	思想
	快速排序通过将一个数组划分成两个子数组，然后通过递归调用自身为每个子数组进行快速排序
2.	如何进行划分
	设定关键字，将比关键字小的放在左边，大的放在右边
3.	如何自动设置关键字
	设置数据最右端的数据为关键字 

```
    /**
     * 快速排序数组划分
     *
     * @param arr   原始数组
     * @param left  左边的数据指针
     * @param right 右边的数据指针
     * @param point 划分的关键字
     */
    private int partition(int arr[], int left, int right, int point) {
        int leftPtr=left-1; //第一个数组之前
        int rightPtr=right; //最后一个数组之后
        while (true) {
            //循环
            //左边的指针不能小于右边的指针，然后左边的指针向中间移动，比关键字小的留着左端
            while (leftPtr<rightPtr && arr[++leftPtr]<point);
            //左边的指针不能小于右边的指针，然后左边的指针向中间移动,比关键字大的留在右端
            while (leftPtr<rightPtr && arr[--rightPtr]>point);
            
            if (leftPtr>=rightPtr){
                break;
            }else{
                int tmp=arr[leftPtr];
                arr[leftPtr]=arr[rightPtr];
                arr[rightPtr]=tmp;
            }
            
        }
        //将当期所指与关键字进行互换
        int tmp=arr[leftPtr];
        arr[leftPtr]=arr[right];
        arr[right]=tmp;
        return leftPtr;
    }
    
    private void sort(int[] arr,int left,int right){
        if(right-left<=0){
            return;
        }
        //设置关键字
        int point=arr[right];
        //获取切入点，同时对数组进行划分
        int partition=partition(arr,left,right,point);
        //对左边的数据进行排序
        sort(arr,left,partition-1);
        sort(arr,partition+1,right);
    }

```
