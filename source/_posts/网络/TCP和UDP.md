---
title: TCP和UDP
categories:
  - 后端
  - 网络
tags:
  - TCP
  - UDP
comments: true
toc: true
abbrlink: 92b9e801
date: 2020-05-24 02:28:12
---

# UDP 和 TCP 的特点与区别
1.  用户数据报协议 UDP（User Datagram Protocol）
是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
2.  传输控制协议 TCP（Transmission Control Protocol）
是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。
--- 


# UDP 、TCP 首部格式
![1.jpeg](http://ww1.sinaimg.cn/large/007lnJOlgy1gf3cj1zx0rj30e3055jrf.jpg)
UDP 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。
![2.jpeg](http://ww1.sinaimg.cn/large/007lnJOlgy1gf3cj67cktj30dw095jrv.jpg)
TCP 首部格式比 UDP 复杂。
- 序号：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- 确认号：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- 数据偏移：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- 控制位：八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。
    
    |  字段   | 含义  |
    |  ----  | ----  |
    | CWR  | CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小 |
    | ECE  | 若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1 |
    | URG  | 紧急指针是否有效。为1，表示某一位需要被优先处理 |
    | ACK  | 确认号是否有效，一般置为1。 |
    | PSH  | 提示接收端应用程序立即从TCP缓冲区把数据读走 |
    | RST  | 对方要求重新建立连接，复位 |
    | SYN  | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1|
    | FIN  | 希望断开连接|

    
- 窗口：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。      

# TCP 的三次握手（为什么三次？）
![3.jpeg](http://ww1.sinaimg.cn/large/007lnJOlgy1gf3e64xaifj30i40bd0tc.jpg)
1.  客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).
2.  服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。
3.  为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。

为什么三次：
客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

- 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

- 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

- 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

# TCP 的四次挥手（为什么四次？）
![4.jpeg](http://ww1.sinaimg.cn/large/007lnJOlgy1gf3eeohxpuj30ik0cvgmp.jpg)
1.  客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 
2.  服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 
3.  服务端发起自己的FIN段，ACK=K+1, Seq=L 
4.  客户端确认。ACK=L+1

# TCP 长连接和短连接的区别
# TCP粘包、拆包及解决办法
# TCP 可靠传输
# TCP 滑动窗口
# TCP 流量控制
# TCP 拥塞控制
# 提供网络利用率