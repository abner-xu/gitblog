---
title: 邻接矩阵无向图
categories:
  - 后端
  - 数据结构
tags:
  - 图
comments: true
toc: true
abbrlink: 45e9daad
date: 2020-02-08 16:23:00
---
# 无向矩阵图代码
```go
package graph

import "fmt"

/**
邻接矩阵无向图
*/
type MatrixUDG struct {
	mVexs   []string //顶点集合
	mMatrix [][]int  //矩阵
	vexnum  int      // 顶点数
	edgnum  int      // 边数
}

/**
通过已存在的图创建

*/
func NewExisting(vexs []string, edges [][]string) *MatrixUDG {
	vexsLeng := len(vexs)
	edgesLeng := len(edges)
	m := &MatrixUDG{
		mVexs:  vexs,
		vexnum: vexsLeng,
		edgnum: edgesLeng,
	}
	// 初始化"顶点"
	mVexs := make([]string, vexsLeng)
	for i := 0; i < len(vexs); i++ {
		mVexs[i] = vexs[i]
	}
	//初始化二维切片
	row, column := vexsLeng, vexsLeng
	for i := 0; i < row; i++ {
		inline := make([]int, column)
		m.mMatrix = append(m.mMatrix, inline)
	}
	for i := 0; i < edgesLeng; i++ {
		// 读取边的起始顶点和结束顶点
		p1 := m.getPosition(edges[i][0])
		p2 := m.getPosition(edges[i][1])
		m.mMatrix[p1][p2] = 1
		m.mMatrix[p2][p1] = 1
	}
	// 初始化"边"

	return m

}

func (m *MatrixUDG) getPosition(s string) int {
	for i := 0; i < len(m.mVexs); i++ {
		if m.mVexs[i] == s {
			return i
		}
	}
	return -1
}

/*
 * 打印矩阵队列图
 */
func (m *MatrixUDG) Print() {
	fmt.Println("Martix Graph:\n")
	for i := 0; i < len(m.mVexs); i++ {
		for j := 0; j < len(m.mVexs); j++ {
			fmt.Printf("%d ", m.mMatrix[i][j])
		}
		fmt.Println()
	}
}

```

# 无向链表图代码
```go
package graph

import "fmt"

/**
邻接链表无向图
*/
type ListUDG struct {
	mVexs []VNode // 顶点数组
	eNode *ENode
	vNode *VNode
}

//邻接表中表对应的链表的顶点
type ENode struct {
	ives     int    // 该边所指向的顶点的位置
	nextEdge *ENode // 指向下一条弧的指针
}

// 邻接表中表的顶点
type VNode struct {
	data      string // 顶点信息
	firstEdge *ENode // 指向第一条依附该顶点的弧
}

/*
 * 创建图(用已提供的矩阵)
 *
 * 参数说明：
 *     vexs  -- 顶点数组
 *     edges -- 边数组
 */
func NewListUDG(vexs []string, edges [][]string) *ListUDG {

	// 初始化"顶点数"和"边数"
	vlen := len(vexs)
	elen := len(edges)
	mVes := make([]VNode, vlen)
	m := &ListUDG{mVexs: mVes}
	for i := 0; i < vlen; i++ {
		mm := &VNode{data: vexs[i], firstEdge: nil}
		mVes[i] = *mm
	}
	//初始化边
	for i := 0; i < elen; i++ {
		// 读取边的起始顶点和结束顶点
		//c1 := edges[i][0]
		//c2 := edges[i][1]
		// 读取边的起始顶点和结束顶点
		p1 := m.getPosition(edges[i][0])
		p2 := m.getPosition(edges[i][1])
		// 初始化node1
		node1 := &ENode{ives: p2}
		// 将node1链接到"p1所在链表的末尾"
		if mVes[p1].firstEdge == nil {
			mVes[p1].firstEdge = node1
		} else {
			m.linkLast(mVes[p1].firstEdge, node1)
		}
		// 初始化node2
		node2 := &ENode{ives: p1}
		// 将node1链接到"p1所在链表的末尾"
		if mVes[p2].firstEdge == nil {
			mVes[p2].firstEdge = node2
		} else {
			m.linkLast(mVes[p2].firstEdge, node2)
		}

	}

	return m

}

func (m *ListUDG) getPosition(s string) int {
	for i := 0; i < len(m.mVexs); i++ {
		if m.mVexs[i].data == s {
			return i
		}
	}
	return -1
}

func (m *ListUDG) linkLast(list *ENode, node *ENode) {
	p := list

	for p.nextEdge != nil {
		p = p.nextEdge
		p.nextEdge = node
	}
}

func (m *ListUDG) Print() {
	/*
	 * 打印矩阵队列图
	 */
	fmt.Printf("List Graph:\n")
	for i := 0; i < len(m.mVexs); i++ {
		fmt.Printf("%d(%s): ", i, m.mVexs[i].data)
		node := m.mVexs[i].firstEdge
		for node != nil {
			fmt.Printf("%d(%s) ", node.ives, m.mVexs[node.ives].data)
			node = node.nextEdge
		}
		fmt.Printf("\n")
	}
}

```

