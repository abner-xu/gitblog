---
title: 栈
categories:
  - 后端
  - 数据结构
tags:
  - 栈
comments: true
toc: true
abbrlink: 1f4ac2fb
date: 2018-11-23 19:45:14
---
# 栈概念
　栈（英语：stack）又称为堆栈或堆叠，栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。

　栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。

　由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。栈也称为后进先出表。

　这里以羽毛球筒为例，羽毛球筒就是一个栈，刚开始羽毛球筒是空的，也就是空栈，然后我们一个一个放入羽毛球，也就是一个一个push进栈，当我们需要使用羽毛球的时候，从筒里面拿，也就是pop出栈，但是第一个拿到的羽毛球是我们最后放进去的。
# 操作流程示意图
![1120165-20171129201940386-674535319.png](http://ww1.sinaimg.cn/large/007lnJOlgy1g9epdmrj20j30b70bigll.jpg)
# 代码
```go
type Stack struct {
	Array []interface{} //栈切片存储
}

func (stack *Stack) Push(value ...interface{}) {
	stack.Array = append(stack.Array, value...)
}

//返回下一个元素
func (stack *Stack) Top() (value interface{}) {
	if stack.Size() > 0 {
		return stack.Array[stack.Size()-1]
	}
	return nil //read empty stack
}

//返回下一个元素,并从Stack移除元素
func (stack *Stack) Pop() interface{} {
	if stack.Size() > 0 {
		value := stack.Array[stack.Size()-1]
		stack.Array = stack.Array[:stack.Size()-1]
		return value
	}
	panic("Stack为空.") //read empty stack
}

//交换值
func (stack *Stack) Swap(other *Stack) {
	switch {
	case stack.Size() == 0 && other.Size() == 0:
		return
	case other.Size() == 0:
		other.Array = stack.Array[:stack.Size()]
		stack.Array = nil
	case stack.Size() == 0:
		stack.Array = other.Array
		other.Array = nil
	default:
		stack.Array, other.Array = other.Array, stack.Array
	}
	return
}

//返回指定索引的元素
func (stack *Stack) Get(idx int) (value interface{}) {
	if idx >= 0 && stack.Size() > 0 && stack.Size() > idx {
		return stack.Array[idx]
	}
	return nil
}

//Stack的size
func (stack *Stack) Size() int {
	return len(stack.Array)
}

```
# 栈-反转字符串
```go
str := "hello,word"
ss := &stack.Stack{}
for _, v := range str {
	ss.Push(string(v))
}
for ss.Size() > 0 {
	fmt.Print(ss.Pop())
}
```